
<!-- saved from url=(0056)https://www.cs.nmsu.edu/~rth/cs/cs177/s98/IntroUIL2.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="GENERATOR" content="Microsoft FrontPage 3.0">
<title>An Introduction to GUI Programming with UIL and Motif</title>
<meta name="Version" content="8.0.4308">
<meta name="Date" content="7/8/97">
<meta name="Template" content="C:\MSOFFICE\Office\HTML.DOT">
</head>

<body text="#000000" link="#0000ff" vlink="#800080" bgcolor="#ffffff">
<b><font face="Arial" size="4">

<p>An Introduction to GUI Programming with UIL and Motif.</p>
</font><font face="Arial"><i>

<p>Why Motif?</p>
</i></font></b>

<p>On the UNIX platform (including Linux), there are several wndowing systems available,
unlike the PC and Macintosh platofrms where choices are much more limited. This presents a
problem since the knowledge of learning one user interface may not transfer to others.
However, the Motif windowing system has gained may followers because it tries to adhere to
industry-wide standards for interaction with a computer using a graphical user interface
(GUI). Motif is based on the X windowing system that is freely available on UNIX
platforms, and adds high-level features and usability without losing any of the basic
capabilities of X. Thus when you learn Motif, you are also learning X, and this knowledge
will transfer to other systems since X is used the basis for other GUIs as well. Motif was
designed by the Open Software Foundation for a consortium of dozens of companies,
including HP, Digital and IBM. They intentionally incorporated many aspects of Microsoft
Windowsand OS/2 (IBM's own OS), which in turn borrowed heavily from the Mac OS. In fact,
we could imagine a hypothetical source for all these windowing systems that gives them all
the same flavor ("look and feel"), even though some of the details are
different:</p>

<p align="CENTER"><img src="./An Introduction to GUI Programming with UIL and Motif_files/image6.gif" width="527" height="239"></p>
<font face="Arial"><i><b>

<p>Programming for a GUI</p>
</b></i></font>

<p>When writing programs for a particular GUI, the programmer needs access to the
libraries that contain all of the pre-compiled code for the interface, and a window
manager that can run the resulting programs. Again, on other platforms this is not a
problem, since Windows programs run in the Windows environment, and Mac programs run on
the Mac. However, not all Motif programs will run on any UNIX system, unless the window
manager, which is that part of the operating system that creates and manages the display,
and allows interaction with the user, is compatible. Having said that, Motif programs will
run on all of our machines in the CS department, so this problem will not arise. </p>

<p>So, we will be using the basic tools available for general C++ programming, i.e. the
compiler g++, and the text editor of your choice, but incorporating Motif library
functions that will interact successfully with the X-based window manager on either
Solaris or Linux machines. In order to do this, we have to understand the principles of
GUI programming, and how to make these work with the Motif libraries, and C++.</p>
<font face="Arial"><i><b>

<p>Principles of Motif programs</p>
</b></i></font>

<p>All Motif programs, whether C or C++ have the same basic main function which carries
out these steps:

</p><ol>
  <li>initialize the X system</li>
  <li>create a main window and possibly other interface items</li>
  <li>hook the interface items to the application program</li>
  <li>display the interface</li>
  <li>enter the event loop, waiting for user interaction</li>
</ol>

<p>The essence of these steps is that a Motif program does nothing until the user requests
some action. The actions are requested by selecting a menu-item, by clicking a button or
other window, or by pressing a key. These, collectively are user <i>gestures</i>. Each
gesture will trigger an application function to carry out some tasks. Thus the familiar
linear sequence of tasks in a program without a user interface is replaced by a collection
of tasks, each of which may be triggered by a user gesture. The diagram below shows these
two models of programs and how they differ:</p>

<p><img src="./An Introduction to GUI Programming with UIL and Motif_files/image5.gif" width="560" height="312"></p>
<font face="Arial">

<p>Terminology</p>
</font>

<p>This basic model is so different there are special words that go with it. The interface
itself consists of <i>widgets</i>, which may be windows, menus or various <i>controls</i>,
such as buttons, check-boxes, or scroll bars. A user gesture, whether from the keyboard or
mouse, corresponds to an <i>event.</i> Events are generated by the widgets that receive
the gesture and are either <i>handled </i>by the widget itself (such as turning on a
check-box) or is sent on to an application function which is called a <i>callback. </i>So,
for instance, the user may select a menu-item. This gesture causes the X system to
highlight the item (it calls the window manager to do this) and then to call the callback
which has been registered to handle the mouse click event. It is the callback that
actually gets work done in the program.</p>
<font face="Arial">

<p>The event loop</p>
</font>

<p>The reason the program's main functions call a function that contains a loop
(essentially an infinite loop that runs until the user requests it to stop) is that user
gestures are <i>asynchronous</i>, i.e. the user must be able to make a gesture
independently of where the program's point of execution is. If the program is busy doing
something when a gesture occurs, the loop will simply put the event on a queue of events
until the program has chance to look at it. The trick is to balance the necessity of
remembering all user gestures (not missing a single one) while still allowing normal
program execution to proceed. Luckily all the hard work has been done and is encapsulated
in the Motif library and the X system itself. The only thing a Motif program has to do to
make the balancing act work is to register the callbacks, and call the event loop
function. Everything else happens transparently.</p>
<font face="Arial"><i><b>

<p>Designing the interface</p>
</b></i></font>

<p>Designing a Motif interface is a pleasant task that can be done independently of
writing the code for it. As long as the range of available widgets and their capabilities
is know, it is essentially a question of assembling a set of off-the-shelf components into
a pleasing design. Issues of usability, simplicity coherence and consistency come into
play here. If there is a bottom line, it is <i>keep it simple. </i>Complex interfaces are
a major reason for programs being left unused, that might otherwise be prefectly capable
of carrying out a task. Menus that are too deeply nested, interfaces with too many windows
and buttons that seem to have no effect are common mistakes.</p>
<font face="Arial"><i><b>

<p>Programming the interface</p>
</b></i></font>

<p>Widgets have to be created with program code at some point. It is actually possible to
make direct calls to the basic X system libraries to do this, but there are so many
details to remember it is very difficult. All these library functions start with a single
upper-case 'X'. A set of consistent library functions that allow a higher level of
programming exist in the X <i>toolkit. </i>These functions start with 'Xt'. However, Motif
packages these up in an even higher level programming interface and these functions start
with 'Xm'. However, even <i>these </i>functions can be hard to use, so there exists a
separate language for designing Motif interfaces that makes the task of taking a design
and realizing it in code as simple as possible. This is the language UIL (user interface
language). Functions in the UIL library start with 'Mrm' (Motif Resource Manager).
[Actually there is an even simpler way to build an interface--the drag and drop visual
technique, but we do not have this available for Motif. ]</p>

<p>UIL code looks vaguely like C, and is quite easy to learn. Once the UIL code is
written, a compiler (called uil) turns it into a binary form that can be read by a special
Mrm library function to create the widgets for the application. The original Motif main
function now looks like this:

</p><ol>
  <li>initialize the X system</li>
  <li>call the Mrm function to read in widget binaries</li>
  <li>hook the interface items to the application program</li>
  <li>display the interface</li>
  <li>enter the event loop, waiting for user interaction</li>
</ol>
<font face="Arial"><i><b>

<p>C++ to the rescue</p>
</b></i></font>

<p>One of the strengths of C++ is the ability to hide implementation detail from the
programmer. With this in mind, I have incorporated the above steps, since they are the
same for any application, into a class called UILApp, and compiled its code into a
library. Using this library is as easy as deriving a new class from UILApp, and putting in
code to register the callbacks, and code specify the files containing the compiled UIL
interface. In the code below, three macros (#define) are used to add a callback, declare a
callback and define it externally to the class. A Motif program that uses UIL now looks
like this:</p>

<pre>// UILApp

#include &lt;iostream.h&gt;
#include &lt;Mrm/MrmAppl.h&gt;
#include "uilapp.h"

//
// derive an application class
//

class MyApp : public UILApp {
public:
  MyApp() {
    // register the callbacks with Motif -- this application has two: print and quit
    // are hooked to interface components
    ADD_CALLBACK(print);
    ADD_CALLBACK(quit);
  }
  // declare the callbacks
  DECLARE_CALLBACK(print);
  DECLARE_CALLBACK(quit);
};

// define each callback function
DEFINE_CALLBACK(MyApp, quit) {
  cout &lt;&lt; "Exiting..." &lt;&lt; endl;
  exit(0);
}

DEFINE_CALLBACK(MyApp, print) {
  char* message = (char*)client_data;
  cout &lt;&lt; message &lt;&lt; endl;
}

int main(int argc, char* argv[]) {
  // the main fucntion crates an application object, registers
  // any number of UIL module files, and calls run
  MyApp app;
  app.AddUILModule("cb");
  app.run(argc, argv);
}</pre>
<font face="Courier New" size="2">

<p>&nbsp;</p>
</font>

<p>It may be worth while looking at the code for the library <a href="https://www.cs.nmsu.edu/~rth/cs/cs177/s98/uilapp.cc">class
UILApp</a>, its <a href="https://www.cs.nmsu.edu/~rth/cs/cs177/s98/uilapp.h">header file</a> and, of course, the <a href="https://www.cs.nmsu.edu/~rth/cs/cs177/s98/cb.uil">UIL
interface sepcification</a>.</p>
<font face="Courier New" size="2">

<p>&nbsp;</p>
</font>

<p>&nbsp;</p>

<p>&nbsp;</p>


</body></html>